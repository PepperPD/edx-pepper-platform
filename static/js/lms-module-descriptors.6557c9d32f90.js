// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.XModule = {
    /*
    Load a single module (either an edit module or a display module)
    from the supplied element, which should have a data-type attribute
    specifying the class to load
    */

    loadModule: function(element) {
      var error, module, moduleType;
      moduleType = $(element).data('type');
      if (moduleType === 'None') {
        return;
      }
      try {
        module = new window[moduleType](element);
        if ($(element).hasClass('xmodule_edit')) {
          $(document).trigger('XModule.loaded.edit', [element, module]);
        }
        if ($(element).hasClass('xmodule_display')) {
          $(document).trigger('XModule.loaded.display', [element, module]);
        }
        return module;
      } catch (_error) {
        error = _error;
        if (window.console && console.log) {
          return console.error("Unable to load " + moduleType + ": " + error.message);
        } else {
          throw error;
        }
      }
    },
    /*
    Load all modules on the page of the specified type.
    If container is provided, only load modules inside that element
    Type is one of 'display' or 'edit'
    */

    loadModules: function(container) {
      var modules, selector;
      selector = ".xmodule_edit, .xmodule_display";
      if (container != null) {
        modules = $(container).find(selector);
      } else {
        modules = $(selector);
      }
      return modules.each(function(idx, element) {
        return XModule.loadModule(element);
      });
    }
  };

  this.XModule.Descriptor = (function() {
    /*
    Register a callback method to be called when the state of this
    descriptor is updated. The callback will be passed the results
    of calling the save method on this descriptor.
    */

    Descriptor.prototype.onUpdate = function(callback) {
      if (this.callbacks == null) {
        this.callbacks = [];
      }
      return this.callbacks.push(callback);
    };

    /*
    Notify registered callbacks that the state of this descriptor has changed
    */


    Descriptor.prototype.update = function() {
      var callback, data, _i, _len, _ref, _results;
      data = this.save();
      _ref = this.callbacks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        _results.push(callback(data));
      }
      return _results;
    };

    /*
    Bind the module to an element. This may be called multiple times,
    if the element content has changed and so the module needs to be rebound
    
    @method: constructor
    @param {html element} the .xmodule_edit section containing all of the descriptor content
    */


    function Descriptor(element) {
      this.element = element;
      this.update = __bind(this.update, this);
      return;
    }

    /*
    Return the current state of the descriptor (to be written to the module store)
    
    @method: save
    @returns {object} An object containing children and data attributes (both optional).
                      The contents of the attributes will be saved to the server
    */


    Descriptor.prototype.save = function() {
      return {};
    };

    return Descriptor;

  })();

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.TabsEditingDescriptor = (function() {
    TabsEditingDescriptor.isInactiveClass = "is-inactive";

    function TabsEditingDescriptor(element) {
      this.onSwitchEditor = __bind(this.onSwitchEditor, this);
      var currentTab,
        _this = this;
      this.element = element;
      /*
      Not tested on syncing of multiple editors of same type in tabs
      (Like many CodeMirrors).
      */

      this.element.closest('.component-editor').find('.component-edit-header').hide();
      this.$tabs = $(".tab", this.element);
      this.$content = $(".component-tab", this.element);
      this.element.find('.editor-tabs .tab').each(function(index, value) {
        return $(value).on('click', _this.onSwitchEditor);
      });
      currentTab = this.$tabs.filter('.current');
      if (currentTab.length !== 1) {
        currentTab = this.$tabs.first();
      }
      this.html_id = this.$tabs.closest('.wrapper-comp-editor').data('html_id');
      currentTab.trigger("click", [true, this.html_id]);
    }

    TabsEditingDescriptor.prototype.onSwitchEditor = function(e, firstTime, html_id) {
      var $currentTarget, content_id, isInactiveClass, onSwitchFunction, previousTab;
      e.preventDefault();
      isInactiveClass = TabsEditingDescriptor.isInactiveClass;
      $currentTarget = $(e.currentTarget);
      if (!$currentTarget.hasClass('current') || firstTime === true) {
        previousTab = null;
        this.$tabs.each(function(index, value) {
          if ($(value).hasClass('current')) {
            return previousTab = $(value).html();
          }
        });
        TabsEditingDescriptor.Model.updateValue(this.html_id, previousTab);
        onSwitchFunction = TabsEditingDescriptor.Model.modules[this.html_id].tabSwitch[$currentTarget.text()];
        if ($.isFunction(onSwitchFunction)) {
          onSwitchFunction();
        }
        this.$tabs.removeClass('current');
        $currentTarget.addClass('current');
        content_id = $currentTarget.attr('href');
        return this.$content.addClass(isInactiveClass).filter(content_id).removeClass(isInactiveClass);
      }
    };

    TabsEditingDescriptor.prototype.save = function() {
      var current_tab;
      this.element.off('click', '.editor-tabs .tab', this.onSwitchEditor);
      current_tab = this.$tabs.filter('.current').html();
      return {
        data: TabsEditingDescriptor.Model.getValue(this.html_id, current_tab)
      };
    };

    TabsEditingDescriptor.Model = {
      addModelUpdate: function(id, tabName, modelUpdateFunction) {
        /*
        Function that registers  'modelUpdate' functions of every tab.
        These functions are used to update value, which will be returned
        by calling save on component.
        */

        this.initialize(id);
        return this.modules[id].modelUpdate[tabName] = modelUpdateFunction;
      },
      addOnSwitch: function(id, tabName, onSwitchFunction) {
        /*
        Function that registers functions invoked when switching
        to particular tab.
        */

        this.initialize(id);
        return this.modules[id].tabSwitch[tabName] = onSwitchFunction;
      },
      updateValue: function(id, tabName) {
        /*
        Function that invokes when switching tabs.
        It ensures that data from previous tab is stored.
        If new tab need this data, it should retrieve it from
        stored value.
        */

        var modelUpdateFunction;
        this.initialize(id);
        modelUpdateFunction = this.modules[id]['modelUpdate'][tabName];
        if ($.isFunction(modelUpdateFunction)) {
          return this.modules[id]['value'] = modelUpdateFunction();
        }
      },
      getValue: function(id, tabName) {
        /*
        Retrieves stored data on component save.
        1. When we switching tabs - previous tab data is always saved to @[id].value
        2. If current tab have registered 'modelUpdate' method, it should be invoked 1st.
        (If we have edited in 1st tab, then switched to 2nd, 2nd tab should
        care about getting data from @[id].value in onSwitch.)
        */

        if (!this.modules[id]) {
          return null;
        }
        if ($.isFunction(this.modules[id]['modelUpdate'][tabName])) {
          return this.modules[id]['modelUpdate'][tabName]();
        } else {
          if (typeof this.modules[id]['value'] === 'undefined') {
            return null;
          } else {
            return this.modules[id]['value'];
          }
        }
      },
      modules: {},
      initialize: function(id) {
        /*
        Initialize objects per id. Id is html_id of descriptor.
        */

        this.modules[id] = this.modules[id] || {};
        this.modules[id].tabSwitch = this.modules[id]['tabSwitch'] || {};
        return this.modules[id].modelUpdate = this.modules[id]['modelUpdate'] || {};
      }
    };

    return TabsEditingDescriptor;

  })();

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.HTMLEditingDescriptor = (function() {
    HTMLEditingDescriptor.isInactiveClass = "is-inactive";

    function HTMLEditingDescriptor(element) {
      this.focusVisualEditor = __bind(this.focusVisualEditor, this);
      this.initInstanceCallback = __bind(this.initInstanceCallback, this);
      this.onSwitchEditor = __bind(this.onSwitchEditor, this);
      this.setupTinyMCE = __bind(this.setupTinyMCE, this);
      var $element;
      this.element = element;
      this.base_asset_url = this.element.find("#editor-tab").data('base-asset-url');
      if (this.base_asset_url === void 0) {
        this.base_asset_url = null;
      }
      this.advanced_editor = CodeMirror.fromTextArea($(".edit-box", this.element)[0], {
        mode: "text/html",
        lineNumbers: true,
        lineWrapping: true
      });
      this.$advancedEditorWrapper = $(this.advanced_editor.getWrapperElement());
      this.$advancedEditorWrapper.addClass(HTMLEditingDescriptor.isInactiveClass);
      tinyMCE.baseURL = '/static/js/vendor/tiny_mce';
      this.tiny_mce_textarea = $(".tiny-mce", this.element).tinymce({
        script_url: '/static/js/vendor/tiny_mce/tiny_mce.js',
        theme: "advanced",
        skin: 'studio',
        schema: "html5",
        convert_urls: false,
        content_css: "/static/css/tiny-mce.css",
        popup_css: '/static/js/vendor/tiny_mce/themes/advanced/skins/default/dialog.css',
        formats: {
          h4: {},
          h5: {},
          h6: {},
          code: {
            inline: 'code'
          }
        },
        visual: false,
        theme_advanced_buttons1: "formatselect,bold,italic,underline,|,bullist,numlist,outdent,indent,|,blockquote,wrapAsCode,|,link,unlink",
        theme_advanced_toolbar_location: "top",
        theme_advanced_toolbar_align: "left",
        theme_advanced_statusbar_location: "none",
        theme_advanced_resizing: true,
        theme_advanced_blockformats: "p,pre,h1,h2,h3",
        width: '100%',
        height: '400px',
        setup: this.setupTinyMCE,
        init_instance_callback: this.initInstanceCallback
      });
      this.showingVisualEditor = true;
      $element = $(element);
      this.$htmlTab = $element.find('.html-tab');
      this.$visualTab = $element.find('.visual-tab');
      this.element.on('click', '.editor-tabs .tab', this.onSwitchEditor);
    }

    HTMLEditingDescriptor.prototype.setupTinyMCE = function(ed) {
      ed.addButton('wrapAsCode', {
        title: 'Code',
        image: '/static/images/ico-tinymce-code.png',
        onclick: function() {
          ed.formatter.toggle('code');
          return ed.isNotDirty = false;
        }
      });
      ed.onNodeChange.add(function(editor, command, e) {
        return command.setActive('wrapAsCode', e.nodeName === 'CODE');
      });
      return this.visualEditor = ed;
    };

    HTMLEditingDescriptor.prototype.onSwitchEditor = function(e) {
      var $currentTarget, visualEditor;
      e.preventDefault();
      $currentTarget = $(e.currentTarget);
      if (!$currentTarget.hasClass('current')) {
        $currentTarget.addClass('current');
        this.$mceToolbar.toggleClass(HTMLEditingDescriptor.isInactiveClass);
        this.$advancedEditorWrapper.toggleClass(HTMLEditingDescriptor.isInactiveClass);
        visualEditor = this.getVisualEditor();
        if ($currentTarget.data('tab') === 'visual') {
          this.$htmlTab.removeClass('current');
          return this.showVisualEditor(visualEditor);
        } else {
          this.$visualTab.removeClass('current');
          return this.showAdvancedEditor(visualEditor);
        }
      }
    };

    HTMLEditingDescriptor.prototype.showAdvancedEditor = function(visualEditor) {
      var content;
      if (visualEditor.isDirty()) {
        content = rewriteStaticLinks(visualEditor.getContent({
          no_events: 1
        }), this.base_asset_url, '/static/');
        this.advanced_editor.setValue(content);
        this.advanced_editor.setCursor(0);
      }
      this.advanced_editor.refresh();
      this.advanced_editor.focus();
      return this.showingVisualEditor = false;
    };

    HTMLEditingDescriptor.prototype.showVisualEditor = function(visualEditor) {
      var content;
      content = rewriteStaticLinks(this.advanced_editor.getValue(), '/static/', this.base_asset_url);
      visualEditor.setContent(content);
      visualEditor.startContent = content;
      this.focusVisualEditor(visualEditor);
      return this.showingVisualEditor = true;
    };

    HTMLEditingDescriptor.prototype.initInstanceCallback = function(visualEditor) {
      visualEditor.setContent(rewriteStaticLinks(this.advanced_editor.getValue(), '/static/', this.base_asset_url));
      return this.focusVisualEditor(visualEditor);
    };

    HTMLEditingDescriptor.prototype.focusVisualEditor = function(visualEditor) {
      visualEditor.focus();
      visualEditor.isNotDirty = true;
      if (this.$mceToolbar == null) {
        return this.$mceToolbar = $(this.element).find('table.mceToolbar');
      }
    };

    HTMLEditingDescriptor.prototype.getVisualEditor = function() {
      /*
      Returns the instance of TinyMCE.
      This is different from the textarea that exists in the HTML template (@tiny_mce_textarea.
      
      Pulled out as a helper method for unit test.
      */

      return this.visualEditor;
    };

    HTMLEditingDescriptor.prototype.save = function() {
      var text, visualEditor;
      this.element.off('click', '.editor-tabs .tab', this.onSwitchEditor);
      text = this.advanced_editor.getValue();
      visualEditor = this.getVisualEditor();
      if (this.showingVisualEditor && visualEditor.isDirty()) {
        text = rewriteStaticLinks(visualEditor.getContent({
          no_events: 1
        }), this.base_asset_url, '/static/');
      }
      return {
        data: text
      };
    };

    return HTMLEditingDescriptor;

  })();

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.SequenceDescriptor = (function(_super) {
    __extends(SequenceDescriptor, _super);

    function SequenceDescriptor(element) {
      var _this = this;
      this.element = element;
      this.$tabs = $(this.element).find("#sequence-list");
      this.$tabs.sortable({
        update: function(event, ui) {
          return _this.update();
        }
      });
    }

    SequenceDescriptor.prototype.save = function() {
      return {
        children: $('#sequence-list li a', this.element).map(function(idx, el) {
          return $(el).data('id');
        }).toArray()
      };
    };

    return SequenceDescriptor;

  })(XModule.Descriptor);

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.MetadataOnlyEditingDescriptor = (function(_super) {
    __extends(MetadataOnlyEditingDescriptor, _super);

    function MetadataOnlyEditingDescriptor(element) {
      this.element = element;
    }

    MetadataOnlyEditingDescriptor.prototype.save = function() {
      return {
        data: null
      };
    };

    return MetadataOnlyEditingDescriptor;

  })(XModule.Descriptor);

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.XMLEditingDescriptor = (function(_super) {
    __extends(XMLEditingDescriptor, _super);

    function XMLEditingDescriptor(element) {
      this.element = element;
      this.edit_box = CodeMirror.fromTextArea($(".edit-box", this.element)[0], {
        mode: "xml",
        lineNumbers: true,
        lineWrapping: true
      });
    }

    XMLEditingDescriptor.prototype.save = function() {
      return {
        data: this.edit_box.getValue()
      };
    };

    return XMLEditingDescriptor;

  })(XModule.Descriptor);

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.MarkdownEditingDescriptor = (function(_super) {
    __extends(MarkdownEditingDescriptor, _super);

    MarkdownEditingDescriptor.multipleChoiceTemplate = "( ) incorrect\n( ) incorrect\n(x) correct\n";

    MarkdownEditingDescriptor.checkboxChoiceTemplate = "[x] correct\n[ ] incorrect\n[x] correct\n";

    MarkdownEditingDescriptor.stringInputTemplate = "= answer\n";

    MarkdownEditingDescriptor.numberInputTemplate = "= answer +- x%\n";

    MarkdownEditingDescriptor.selectTemplate = "[[incorrect, (correct), incorrect]]\n";

    MarkdownEditingDescriptor.headerTemplate = "Header\n=====\n";

    MarkdownEditingDescriptor.explanationTemplate = "[explanation]\nShort explanation\n[explanation]\n";

    function MarkdownEditingDescriptor(element) {
      this.toggleCheatsheet = __bind(this.toggleCheatsheet, this);
      this.onToolbarButton = __bind(this.onToolbarButton, this);
      this.onShowXMLButton = __bind(this.onShowXMLButton, this);
      this.element = element;
      if ($(".markdown-box", this.element).length !== 0) {
        this.markdown_editor = CodeMirror.fromTextArea($(".markdown-box", element)[0], {
          lineWrapping: true,
          mode: null
        });
        this.setCurrentEditor(this.markdown_editor);
        this.element.on('click', '.xml-tab', this.onShowXMLButton);
        this.element.on('click', '.format-buttons a', this.onToolbarButton);
        this.element.on('click', '.cheatsheet-toggle', this.toggleCheatsheet);
        $(this.element.find('.xml-box')).hide();
      } else {
        this.createXMLEditor();
      }
    }

    /*
    Creates the XML Editor and sets it as the current editor. If text is passed in,
    it will replace the text present in the HTML template.
    
    text: optional argument to override the text passed in via the HTML template
    */


    MarkdownEditingDescriptor.prototype.createXMLEditor = function(text) {
      this.xml_editor = CodeMirror.fromTextArea($(".xml-box", this.element)[0], {
        mode: "xml",
        lineNumbers: true,
        lineWrapping: true
      });
      if (text) {
        this.xml_editor.setValue(text);
      }
      return this.setCurrentEditor(this.xml_editor);
    };

    /*
    User has clicked to show the XML editor. Before XML editor is swapped in,
    the user will need to confirm the one-way conversion.
    */


    MarkdownEditingDescriptor.prototype.onShowXMLButton = function(e) {
      e.preventDefault();
      if (this.confirmConversionToXml()) {
        this.createXMLEditor(MarkdownEditingDescriptor.markdownToXml(this.markdown_editor.getValue()));
        this.xml_editor.setCursor(0);
        this.xml_editor.refresh();
        return $(this.element.find('.editor-bar')).hide();
      }
    };

    /*
    Have the user confirm the one-way conversion to XML.
    Returns true if the user clicked OK, else false.
    */


    MarkdownEditingDescriptor.prototype.confirmConversionToXml = function() {
      return confirm("If you use the Advanced Editor, this problem will be converted to XML and you will not be able to return to the Simple Editor Interface.\n\nProceed to the Advanced Editor and convert this problem to XML?");
    };

    /*
    Event listener for toolbar buttons (only possible when markdown editor is visible).
    */


    MarkdownEditingDescriptor.prototype.onToolbarButton = function(e) {
      var revisedSelection, selection;
      e.preventDefault();
      selection = this.markdown_editor.getSelection();
      revisedSelection = null;
      switch ($(e.currentTarget).attr('class')) {
        case "multiple-choice-button":
          revisedSelection = MarkdownEditingDescriptor.insertMultipleChoice(selection);
          break;
        case "string-button":
          revisedSelection = MarkdownEditingDescriptor.insertStringInput(selection);
          break;
        case "number-button":
          revisedSelection = MarkdownEditingDescriptor.insertNumberInput(selection);
          break;
        case "checks-button":
          revisedSelection = MarkdownEditingDescriptor.insertCheckboxChoice(selection);
          break;
        case "dropdown-button":
          revisedSelection = MarkdownEditingDescriptor.insertSelect(selection);
          break;
        case "header-button":
          revisedSelection = MarkdownEditingDescriptor.insertHeader(selection);
          break;
        case "explanation-button":
          revisedSelection = MarkdownEditingDescriptor.insertExplanation(selection);
          break;
      }
      if (revisedSelection !== null) {
        this.markdown_editor.replaceSelection(revisedSelection);
        return this.markdown_editor.focus();
      }
    };

    /*
    Event listener for toggling cheatsheet (only possible when markdown editor is visible).
    */


    MarkdownEditingDescriptor.prototype.toggleCheatsheet = function(e) {
      var _this = this;
      e.preventDefault();
      if (!$(this.markdown_editor.getWrapperElement()).find('.simple-editor-cheatsheet')[0]) {
        this.cheatsheet = $($('#simple-editor-cheatsheet').html());
        $(this.markdown_editor.getWrapperElement()).append(this.cheatsheet);
      }
      return setTimeout((function() {
        return _this.cheatsheet.toggleClass('shown');
      }), 10);
    };

    /*
    Stores the current editor and hides the one that is not displayed.
    */


    MarkdownEditingDescriptor.prototype.setCurrentEditor = function(editor) {
      if (this.current_editor) {
        $(this.current_editor.getWrapperElement()).hide();
      }
      this.current_editor = editor;
      $(this.current_editor.getWrapperElement()).show();
      return $(this.current_editor).focus();
    };

    /*
    Called when save is called. Listeners are unregistered because editing the block again will
    result in a new instance of the descriptor. Note that this is NOT the case for cancel--
    when cancel is called the instance of the descriptor is reused if edit is selected again.
    */


    MarkdownEditingDescriptor.prototype.save = function() {
      this.element.off('click', '.xml-tab', this.changeEditor);
      this.element.off('click', '.format-buttons a', this.onToolbarButton);
      this.element.off('click', '.cheatsheet-toggle', this.toggleCheatsheet);
      if (this.current_editor === this.markdown_editor) {
        return {
          data: MarkdownEditingDescriptor.markdownToXml(this.markdown_editor.getValue()),
          metadata: {
            markdown: this.markdown_editor.getValue()
          }
        };
      } else {
        return {
          data: this.xml_editor.getValue(),
          nullout: ['markdown']
        };
      }
    };

    MarkdownEditingDescriptor.insertMultipleChoice = function(selectedText) {
      return MarkdownEditingDescriptor.insertGenericChoice(selectedText, '(', ')', MarkdownEditingDescriptor.multipleChoiceTemplate);
    };

    MarkdownEditingDescriptor.insertCheckboxChoice = function(selectedText) {
      return MarkdownEditingDescriptor.insertGenericChoice(selectedText, '[', ']', MarkdownEditingDescriptor.checkboxChoiceTemplate);
    };

    MarkdownEditingDescriptor.insertGenericChoice = function(selectedText, choiceStart, choiceEnd, template) {
      var cleanSelectedText, line, lines, revisedLines, _i, _len;
      if (selectedText.length > 0) {
        cleanSelectedText = selectedText.replace(/\n+/g, '\n').replace(/\n$/, '');
        lines = cleanSelectedText.split('\n');
        revisedLines = '';
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          revisedLines += choiceStart;
          if (/^\s*x\s+(\S)/i.test(line)) {
            line = line.replace(/^\s*x\s+(\S)/i, '$1');
            revisedLines += 'x';
          } else {
            revisedLines += ' ';
          }
          revisedLines += choiceEnd + ' ' + line + '\n';
        }
        return revisedLines;
      } else {
        return template;
      }
    };

    MarkdownEditingDescriptor.insertStringInput = function(selectedText) {
      return MarkdownEditingDescriptor.insertGenericInput(selectedText, '= ', '', MarkdownEditingDescriptor.stringInputTemplate);
    };

    MarkdownEditingDescriptor.insertNumberInput = function(selectedText) {
      return MarkdownEditingDescriptor.insertGenericInput(selectedText, '= ', '', MarkdownEditingDescriptor.numberInputTemplate);
    };

    MarkdownEditingDescriptor.insertSelect = function(selectedText) {
      return MarkdownEditingDescriptor.insertGenericInput(selectedText, '[[', ']]', MarkdownEditingDescriptor.selectTemplate);
    };

    MarkdownEditingDescriptor.insertHeader = function(selectedText) {
      return MarkdownEditingDescriptor.insertGenericInput(selectedText, '', '\n====\n', MarkdownEditingDescriptor.headerTemplate);
    };

    MarkdownEditingDescriptor.insertExplanation = function(selectedText) {
      return MarkdownEditingDescriptor.insertGenericInput(selectedText, '[explanation]\n', '\n[explanation]', MarkdownEditingDescriptor.explanationTemplate);
    };

    MarkdownEditingDescriptor.insertGenericInput = function(selectedText, lineStart, lineEnd, template) {
      if (selectedText.length > 0) {
        return lineStart + selectedText + lineEnd;
      } else {
        return template;
      }
    };

    MarkdownEditingDescriptor.markdownToXml = function(markdown) {
      var toXml;
      toXml = function(markdown) {
      var xml = markdown;

      // replace headers
      xml = xml.replace(/(^.*?$)(?=\n\=\=+$)/gm, '<h1>$1</h1>');
      xml = xml.replace(/\n^\=\=+$/gm, '');

      // group multiple choice answers
      xml = xml.replace(/(^\s*\(.?\).*?$\n*)+/gm, function(match, p) {
        var groupString = '<multiplechoiceresponse>\n';
        groupString += '  <choicegroup type="MultipleChoice">\n';
        var options = match.split('\n');
        for(var i = 0; i < options.length; i++) {
          if(options[i].length > 0) {
            var value = options[i].split(/^\s*\(.?\)\s*/)[1];
            var correct = /^\s*\(x\)/i.test(options[i]);
            groupString += '    <choice correct="' + correct + '">' + value + '</choice>\n';
          }
        }
        groupString += '  </choicegroup>\n';
        groupString += '</multiplechoiceresponse>\n\n';
        return groupString;
      });

      // group check answers
      xml = xml.replace(/(^\s*\[.?\].*?$\n*)+/gm, function(match, p) {
        var groupString = '<choiceresponse>\n';
        groupString += '  <checkboxgroup direction="vertical">\n';
        var options = match.split('\n');
        for(var i = 0; i < options.length; i++) {
          if(options[i].length > 0) {
            var value = options[i].split(/^\s*\[.?\]\s*/)[1];
            var correct = /^\s*\[x\]/i.test(options[i]);
            groupString += '    <choice correct="' + correct + '">' + value + '</choice>\n';
          }
        }
        groupString += '  </checkboxgroup>\n';
        groupString += '</choiceresponse>\n\n';
        return groupString;
      });

      // replace string and numerical
      xml = xml.replace(/^\=\s*(.*?$)/gm, function(match, p) {
        var string;
        var floatValue = parseFloat(p);
        if(!isNaN(floatValue)) {
          var params = /(.*?)\+\-\s*(.*?$)/.exec(p);
          if(params) {
            string = '<numericalresponse answer="' + floatValue + '">\n';
            string += '  <responseparam type="tolerance" default="' + params[2] + '" />\n';
          } else {
            string = '<numericalresponse answer="' + floatValue + '">\n';
          }
          string += '  <formulaequationinput />\n';
          string += '</numericalresponse>\n\n';
        } else {
          string = '<stringresponse answer="' + p + '" type="ci">\n  <textline size="20"/>\n</stringresponse>\n\n';
        }
        return string;
      });

      // replace selects
      xml = xml.replace(/\[\[(.+?)\]\]/g, function(match, p) {
        var selectString = '\n<optionresponse>\n';
        selectString += '  <optioninput options="(';
        var options = p.split(/\,\s*/g);
        for(var i = 0; i < options.length; i++) {
          selectString += "'" + options[i].replace(/(?:^|,)\s*\((.*?)\)\s*(?:$|,)/g, '$1') + "'" + (i < options.length -1 ? ',' : '');
        }
        selectString += ')" correct="';
        var correct = /(?:^|,)\s*\((.*?)\)\s*(?:$|,)/g.exec(p);
        if (correct) selectString += correct[1];
        selectString += '"></optioninput>\n';
        selectString += '</optionresponse>\n\n';
        return selectString;
      });
      
      // replace explanations
      xml = xml.replace(/\[explanation\]\n?([^\]]*)\[\/?explanation\]/gmi, function(match, p1) {
          var selectString = '<solution>\n<div class="detailed-solution">\nExplanation\n\n' + p1 + '\n</div>\n</solution>';
          return selectString;
      });

      // split scripts and wrap paragraphs
      var splits = xml.split(/(\<\/?script.*?\>)/g);
      var scriptFlag = false;
      for(var i = 0; i < splits.length; i++) {
        if(/\<script/.test(splits[i])) {
          scriptFlag = true;
        }
        if(!scriptFlag) {
          splits[i] = splits[i].replace(/(^(?!\s*\<|$).*$)/gm, '<p>$1</p>');
        }
        if(/\<\/script/.test(splits[i])) {
          scriptFlag = false;
        }
      }
      xml = splits.join('');

      // rid white space
      xml = xml.replace(/\n\n\n/g, '\n');
      
      // surround w/ problem tag
      xml = '<problem>\n' + xml + '\n</problem>';

      return xml;
    }
    ;
      return toXml(markdown);
    };

    return MarkdownEditingDescriptor;

  })(XModule.Descriptor);

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.OpenEndedMarkdownEditingDescriptor = (function(_super) {
    __extends(OpenEndedMarkdownEditingDescriptor, _super);

    OpenEndedMarkdownEditingDescriptor.rubricTemplate = "[rubric]\n+ Ideas\n- Difficult for the reader to discern the main idea.  Too brief or too repetitive to establish or maintain a focus.\n- Attempts a main idea.  Sometimes loses focus or ineffectively displays focus.\n- Presents a unifying theme or main idea, but may include minor tangents.  Stays somewhat focused on topic and task.\n- Presents a unifying theme or main idea without going off on tangents.  Stays completely focused on topic and task.\n+ Content\n- Includes little information with few or no details or unrelated details.  Unsuccessful in attempts to explore any facets of the topic.\n- Includes little information and few or no details.  Explores only one or two facets of the topic.\n- Includes sufficient information and supporting details. (Details may not be fully developed; ideas may be listed.)  Explores some facets of the topic.\n- Includes in-depth information and exceptional supporting details that are fully developed.  Explores all facets of the topic.\n+ Organization\n- Ideas organized illogically, transitions weak, and response difficult to follow.\n- Attempts to logically organize ideas.  Attempts to progress in an order that enhances meaning, and demonstrates use of transitions.\n- Ideas organized logically.  Progresses in an order that enhances meaning.  Includes smooth transitions.\n+ Style\n- Contains limited vocabulary, with many words used incorrectly.  Demonstrates problems with sentence patterns.\n- Contains basic vocabulary, with words that are predictable and common.  Contains mostly simple sentences (although there may be an attempt at more varied sentence patterns).\n- Includes vocabulary to make explanations detailed and precise.  Includes varied sentence patterns, including complex sentences.\n+ Voice\n- Demonstrates language and tone that may be inappropriate to task and reader.\n- Demonstrates an attempt to adjust language and tone to task and reader.\n- Demonstrates effective adjustment of language and tone to task and reader.\n[rubric]";

    OpenEndedMarkdownEditingDescriptor.tasksTemplate = "[tasks]\n(Self), ({4-12}AI), ({9-12}Peer)\n[tasks]\n";

    OpenEndedMarkdownEditingDescriptor.promptTemplate = "[prompt]\n\n<h3>Censorship in the Libraries</h3>\n\n<p>'All of us can think of a book that we hope none of our children or any other children have taken off the shelf. But if I have the right to remove that book from the shelf -- that work I abhor -- then you also have exactly the same right and so does everyone else. And then we have no books left on the shelf for any of us.' --Katherine Paterson, Author\n</p>\n\n<p>\nWrite a persuasive essay to a newspaper reflecting your vies on censorship in libraries. Do you believe that certain materials, such as books, music, movies, magazines, etc., should be removed from the shelves if they are found offensive? Support your position with convincing arguments from your own experience, observations, and/or reading.\n</p>\n[prompt]\n";

    function OpenEndedMarkdownEditingDescriptor(element) {
      this.toggleCheatsheet = __bind(this.toggleCheatsheet, this);
      this.onToolbarButton = __bind(this.onToolbarButton, this);
      this.onShowXMLButton = __bind(this.onShowXMLButton, this);
      var selection;
      this.element = element;
      if ($(".markdown-box", this.element).length !== 0) {
        this.markdown_editor = CodeMirror.fromTextArea($(".markdown-box", element)[0], {
          lineWrapping: true,
          mode: null
        });
        this.setCurrentEditor(this.markdown_editor);
        selection = this.markdown_editor.getSelection();
        if (this.markdown_editor.getValue() === "") {
          this.markdown_editor.setValue(OpenEndedMarkdownEditingDescriptor.promptTemplate + "\n" + OpenEndedMarkdownEditingDescriptor.rubricTemplate + "\n" + OpenEndedMarkdownEditingDescriptor.tasksTemplate);
        }
        this.element.on('click', '.xml-tab', this.onShowXMLButton);
        this.element.on('click', '.format-buttons a', this.onToolbarButton);
        this.element.on('click', '.cheatsheet-toggle', this.toggleCheatsheet);
        $(this.element.find('.xml-box')).hide();
      } else {
        this.createXMLEditor();
      }
      this.alertTaskRubricModification();
    }

    /*
    Creates the XML Editor and sets it as the current editor. If text is passed in,
    it will replace the text present in the HTML template.
    
    text: optional argument to override the text passed in via the HTML template
    */


    OpenEndedMarkdownEditingDescriptor.prototype.createXMLEditor = function(text) {
      this.xml_editor = CodeMirror.fromTextArea($(".xml-box", this.element)[0], {
        mode: "xml",
        lineNumbers: true,
        lineWrapping: true
      });
      if (text) {
        this.xml_editor.setValue(text);
      }
      return this.setCurrentEditor(this.xml_editor);
    };

    /*
    User has clicked to show the XML editor. Before XML editor is swapped in,
    the user will need to confirm the one-way conversion.
    */


    OpenEndedMarkdownEditingDescriptor.prototype.onShowXMLButton = function(e) {
      e.preventDefault();
      if (this.confirmConversionToXml()) {
        this.createXMLEditor(OpenEndedMarkdownEditingDescriptor.markdownToXml(this.markdown_editor.getValue()));
        this.xml_editor.setCursor(0);
        this.xml_editor.refresh();
        return $(this.element.find('.editor-bar')).hide();
      }
    };

    OpenEndedMarkdownEditingDescriptor.prototype.alertTaskRubricModification = function() {
      return alert("Before you edit, please note that if you alter the tasks block or the rubric block of this question after students have submitted responses, it may result in their responses and grades being deleted!  Use caution when altering problems that have already been released to students.");
    };

    /*
    Have the user confirm the one-way conversion to XML.
    Returns true if the user clicked OK, else false.
    */


    OpenEndedMarkdownEditingDescriptor.prototype.confirmConversionToXml = function() {
      return confirm("If you use the Advanced Editor, this problem will be converted to XML and you will not be able to return to the Simple Editor Interface.\n\nProceed to the Advanced Editor and convert this problem to XML?");
    };

    /*
    Event listener for toolbar buttons (only possible when markdown editor is visible).
    */


    OpenEndedMarkdownEditingDescriptor.prototype.onToolbarButton = function(e) {
      var revisedSelection, selection;
      e.preventDefault();
      selection = this.markdown_editor.getSelection();
      revisedSelection = null;
      switch ($(e.currentTarget).attr('class')) {
        case "rubric-button":
          revisedSelection = OpenEndedMarkdownEditingDescriptor.insertRubric(selection);
          break;
        case "prompt-button":
          revisedSelection = OpenEndedMarkdownEditingDescriptor.insertPrompt(selection);
          break;
        case "tasks-button":
          revisedSelection = OpenEndedMarkdownEditingDescriptor.insertTasks(selection);
          break;
      }
      if (revisedSelection !== null) {
        this.markdown_editor.replaceSelection(revisedSelection);
        return this.markdown_editor.focus();
      }
    };

    /*
    Event listener for toggling cheatsheet (only possible when markdown editor is visible).
    */


    OpenEndedMarkdownEditingDescriptor.prototype.toggleCheatsheet = function(e) {
      var _this = this;
      e.preventDefault();
      if (!$(this.markdown_editor.getWrapperElement()).find('.simple-editor-open-ended-cheatsheet')[0]) {
        this.cheatsheet = $($('#simple-editor-open-ended-cheatsheet').html());
        $(this.markdown_editor.getWrapperElement()).append(this.cheatsheet);
      }
      return setTimeout((function() {
        return _this.cheatsheet.toggleClass('shown');
      }), 10);
    };

    /*
    Stores the current editor and hides the one that is not displayed.
    */


    OpenEndedMarkdownEditingDescriptor.prototype.setCurrentEditor = function(editor) {
      if (this.current_editor) {
        $(this.current_editor.getWrapperElement()).hide();
      }
      this.current_editor = editor;
      $(this.current_editor.getWrapperElement()).show();
      return $(this.current_editor).focus();
    };

    /*
    Called when save is called. Listeners are unregistered because editing the block again will
    result in a new instance of the descriptor. Note that this is NOT the case for cancel--
    when cancel is called the instance of the descriptor is reused if edit is selected again.
    */


    OpenEndedMarkdownEditingDescriptor.prototype.save = function() {
      this.element.off('click', '.xml-tab', this.changeEditor);
      this.element.off('click', '.format-buttons a', this.onToolbarButton);
      this.element.off('click', '.cheatsheet-toggle', this.toggleCheatsheet);
      if (this.current_editor === this.markdown_editor) {
        return {
          data: OpenEndedMarkdownEditingDescriptor.markdownToXml(this.markdown_editor.getValue()),
          metadata: {
            markdown: this.markdown_editor.getValue()
          }
        };
      } else {
        return {
          data: this.xml_editor.getValue(),
          nullout: ['markdown']
        };
      }
    };

    OpenEndedMarkdownEditingDescriptor.insertRubric = function(selectedText) {
      return OpenEndedMarkdownEditingDescriptor.insertGenericInput(selectedText, '[rubric]', '[rubric]', OpenEndedMarkdownEditingDescriptor.rubricTemplate);
    };

    OpenEndedMarkdownEditingDescriptor.insertPrompt = function(selectedText) {
      return OpenEndedMarkdownEditingDescriptor.insertGenericInput(selectedText, '[prompt]', '[prompt]', OpenEndedMarkdownEditingDescriptor.promptTemplate);
    };

    OpenEndedMarkdownEditingDescriptor.insertTasks = function(selectedText) {
      return OpenEndedMarkdownEditingDescriptor.insertGenericInput(selectedText, '[tasks]', '[tasks]', OpenEndedMarkdownEditingDescriptor.tasksTemplate);
    };

    OpenEndedMarkdownEditingDescriptor.insertGenericInput = function(selectedText, lineStart, lineEnd, template) {
      var new_string;
      if (selectedText.length > 0) {
        new_string = selectedText.replace(/^\s+|\s+$/g, '');
        if (new_string.substring(0, lineStart.length) !== lineStart) {
          new_string = lineStart + new_string;
        }
        if (new_string.substring(new_string.length - lineEnd.length, new_string.length) !== lineEnd) {
          new_string = new_string + lineEnd;
        }
        return new_string;
      } else {
        return template;
      }
    };

    OpenEndedMarkdownEditingDescriptor.markdownToXml = function(markdown) {
      var toXml;
      toXml = function(markdown) {

      function template(template_html,data){
        return template_html.replace(/%(\w*)%/g,function(m,key){return data.hasOwnProperty(key)?data[key]:"";});
      }

      var xml = markdown;

      // group rubrics
      xml = xml.replace(/\[rubric\]\n?([^\]]*)\[\/?rubric\]/gmi, function(match, p) {
        var groupString = '<rubric>\n<rubric>\n';
        var options = p.split('\n');
        var category_open = false;
        for(var i = 0; i < options.length; i++) {
          if(options[i].length > 0) {
            var value = options[i].replace(/^\s+|\s+$/g,'');
            if (value.charAt(0)=="+") {
              if(i>0){
                if(category_open==true){
                  groupString += "</category>\n";
                  category_open = false;
                }
              }
              groupString += "<category>\n<description>\n";
              category_open = true;
              text = value.substr(1);
              text = text.replace(/^\s+|\s+$/g,'');
              groupString += text;
              groupString += "\n</description>\n";
            } else if (value.charAt(0) == "-") {
              groupString += "<option>\n";
              text = value.substr(1);
              text = text.replace(/^\s+|\s+$/g,'');
              groupString += text;
              groupString += "\n</option>\n";
            }
          }
          if(i==options.length-1 && category_open == true){
            groupString += "\n</category>\n";
          }
        }
        groupString += '</rubric>\n</rubric>\n';
        return groupString;
      });

      // group tasks
      xml = xml.replace(/\[tasks\]\n?([^\]]*)\[\/?tasks\]/gmi, function(match, p) {
        var open_ended_template = $('#open-ended-template').html();
        if(open_ended_template == null) {
          open_ended_template = "<openended %min_max_string%>%grading_config%</openended>";
        }
        var groupString = '';
        var options = p.split(",");
        for(var i = 0; i < options.length; i++) {
          if(options[i].length > 0) {
            var value = options[i].replace(/^\s+|\s+$/g,'');
            var lower_option = value.toLowerCase();
            type = lower_option.match(/(peer|self|ai)/gmi)
            if(type != null) {
              type = type[0]
              var min_max = value.match(/\{\n?([^\]]*)\}/gmi);
              var min_max_string = "";
              if(min_max!=null) {
                min_max = min_max[0].replace(/^{|}/gmi,'');
                min_max = min_max.split("-");
                min = min_max[0];
                max = min_max[1];
                min_max_string = 'min_score_to_attempt="' + min + '" max_score_to_attempt="' + max + '" ';
              }
              groupString += "<task>\n"
              if(type=="self") {
                groupString +="<selfassessment" + min_max_string + "/>"
              } else if (type=="peer") {
                config = "peer_grading.conf"
                groupString += template(open_ended_template,{min_max_string: min_max_string, grading_config: config});
              } else if (type=="ai") {
                                       config = "ml_grading.conf"
                                       groupString += template(open_ended_template,{min_max_string: min_max_string, grading_config: config});
              }
              groupString += "</task>\n"
            }
          }
        }
        return groupString;
      });

      // replace prompts
      xml = xml.replace(/\[prompt\]\n?([^\]]*)\[\/?prompt\]/gmi, function(match, p1) {
          var selectString = '<prompt>\n' + p1 + '\n</prompt>';
          return selectString;
      });

      // rid white space
      xml = xml.replace(/\n\n\n/g, '\n');

      // surround w/ combinedopenended tag
      xml = '<combinedopenended>\n' + xml + '\n</combinedopenended>';

      return xml;
    }
    ;
      return toXml(markdown);
    };

    return OpenEndedMarkdownEditingDescriptor;

  })(XModule.Descriptor);

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.VerticalDescriptor = (function(_super) {
    __extends(VerticalDescriptor, _super);

    function VerticalDescriptor(element) {
      var _this = this;
      this.element = element;
      this.$items = $(this.element).find(".vert-mod");
      this.$items.sortable({
        update: function(event, ui) {
          return _this.update();
        }
      });
    }

    VerticalDescriptor.prototype.save = function() {
      return {
        children: $('.vert-mod li', this.element).map(function(idx, el) {
          return $(el).data('id');
        }).toArray()
      };
    };

    return VerticalDescriptor;

  })(XModule.Descriptor);

}).call(this);
