// Generated by CoffeeScript 1.6.3
(function() {
  describe('Problem', function() {
    beforeEach(function() {
      window.MathJax = {
        Hub: jasmine.createSpyObj('MathJax.Hub', ['getAllJax', 'Queue']),
        Callback: jasmine.createSpyObj('MathJax.Callback', ['After'])
      };
      this.stubbedJax = {
        root: jasmine.createSpyObj('jax.root', ['toMathML'])
      };
      MathJax.Hub.getAllJax.andReturn([this.stubbedJax]);
      window.update_schematics = function() {};
      jasmine.stubRequests();
      loadFixtures('problem.html');
      spyOn(Logger, 'log');
      return spyOn($.fn, 'load').andCallFake(function(url, callback) {
        $(this).html(readFixtures('problem_content.html'));
        return callback();
      });
    });
    describe('constructor', function() {
      it('set the element from html', function() {
        this.problem999 = new Problem("        <section class='xmodule_display xmodule_CapaModule' data-type='Problem'>          <section id='problem_999'                   class='problems-wrapper'                   data-problem-id='i4x://edX/999/problem/Quiz'                   data-url='/problem/quiz/'>          </section>        </section>        ");
        return expect(this.problem999.element_id).toBe('problem_999');
      });
      return it('set the element from loadFixtures', function() {
        this.problem1 = new Problem($('.xmodule_display'));
        return expect(this.problem1.element_id).toBe('problem_1');
      });
    });
    describe('bind', function() {
      beforeEach(function() {
        spyOn(window, 'update_schematics');
        MathJax.Hub.getAllJax.andReturn([this.stubbedJax]);
        return this.problem = new Problem($('.xmodule_display'));
      });
      it('set mathjax typeset', function() {
        return expect(MathJax.Hub.Queue).toHaveBeenCalled();
      });
      it('update schematics', function() {
        return expect(window.update_schematics).toHaveBeenCalled();
      });
      it('bind answer refresh on button click', function() {
        return expect($('section.action input:button')).toHandleWith('click', this.problem.refreshAnswers);
      });
      it('bind the check button', function() {
        return expect($('section.action input.check')).toHandleWith('click', this.problem.check_fd);
      });
      it('bind the reset button', function() {
        return expect($('section.action input.reset')).toHandleWith('click', this.problem.reset);
      });
      it('bind the show button', function() {
        return expect($('section.action button.show')).toHandleWith('click', this.problem.show);
      });
      it('bind the save button', function() {
        return expect($('section.action input.save')).toHandleWith('click', this.problem.save);
      });
      it('bind the math input', function() {
        return expect($('input.math')).toHandleWith('keyup', this.problem.refreshMath);
      });
      return xit('replace math content on the page', function() {
        return expect(MathJax.Hub.Queue.mostRecentCall.args).toEqual([['Text', this.stubbedJax, ''], [this.problem.updateMathML, this.stubbedJax, $('#input_example_1').get(0)]]);
      });
    });
    describe('renderProgressState', function() {
      beforeEach(function() {
        return this.problem = new Problem($('.xmodule_display'));
      });
      describe('with a status of "none"', function() {
        return it('reports the number of points possible', function() {
          this.problem.el.data('progress_status', 'none');
          this.problem.el.data('progress_detail', '0/1');
          this.problem.renderProgressState();
          return expect(this.problem.$('.problem-progress').html()).toEqual("(1 point possible)");
        });
      });
      return describe('with any other valid status', function() {
        return it('reports the current score', function() {
          this.problem.el.data('progress_status', 'foo');
          this.problem.el.data('progress_detail', '1/1');
          this.problem.renderProgressState();
          return expect(this.problem.$('.problem-progress').html()).toEqual("(1/1 points)");
        });
      });
    });
    describe('render', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xmodule_display'));
        this.bind = this.problem.bind;
        return spyOn(this.problem, 'bind');
      });
      describe('with content given', function() {
        beforeEach(function() {
          return this.problem.render('Hello World');
        });
        it('render the content', function() {
          return expect(this.problem.el.html()).toEqual('Hello World');
        });
        return it('re-bind the content', function() {
          return expect(this.problem.bind).toHaveBeenCalled();
        });
      });
      return describe('with no content given', function() {
        beforeEach(function() {
          spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
            return callback({
              html: "Hello World"
            });
          });
          return this.problem.render();
        });
        it('load the content via ajax', function() {
          return expect(this.problem.el.html()).toEqual('Hello World');
        });
        return it('re-bind the content', function() {
          return expect(this.problem.bind).toHaveBeenCalled();
        });
      });
    });
    describe('check_fd', function() {
      return xit('should have more specs written for this functionality', function() {
        return expect(false);
      });
    });
    describe('check', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xmodule_display'));
        return this.problem.answers = 'foo=1&bar=2';
      });
      it('log the problem_check event', function() {
        this.problem.check();
        return expect(Logger.log).toHaveBeenCalledWith('problem_check', 'foo=1&bar=2');
      });
      it('log the problem_graded event, after the problem is done grading.', function() {
        spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
          var response;
          response = {
            success: 'correct',
            contents: 'mock grader response'
          };
          return callback(response);
        });
        this.problem.check();
        return expect(Logger.log).toHaveBeenCalledWith('problem_graded', ['foo=1&bar=2', 'mock grader response'], this.problem.url);
      });
      it('submit the answer for check', function() {
        spyOn($, 'postWithPrefix');
        this.problem.check();
        return expect($.postWithPrefix).toHaveBeenCalledWith('/problem/Problem1/problem_check', 'foo=1&bar=2', jasmine.any(Function));
      });
      describe('when the response is correct', function() {
        return it('call render with returned content', function() {
          spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
            return callback({
              success: 'correct',
              contents: 'Correct!'
            });
          });
          this.problem.check();
          return expect(this.problem.el.html()).toEqual('Correct!');
        });
      });
      describe('when the response is incorrect', function() {
        return it('call render with returned content', function() {
          spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
            return callback({
              success: 'incorrect',
              contents: 'Incorrect!'
            });
          });
          this.problem.check();
          return expect(this.problem.el.html()).toEqual('Incorrect!');
        });
      });
      return xdescribe('when the response is undetermined', function() {
        return it('alert the response', function() {
          spyOn(window, 'alert');
          spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
            return callback({
              success: 'Number Only!'
            });
          });
          this.problem.check();
          return expect(window.alert).toHaveBeenCalledWith('Number Only!');
        });
      });
    });
    describe('reset', function() {
      beforeEach(function() {
        return this.problem = new Problem($('.xmodule_display'));
      });
      it('log the problem_reset event', function() {
        this.problem.answers = 'foo=1&bar=2';
        this.problem.reset();
        return expect(Logger.log).toHaveBeenCalledWith('problem_reset', 'foo=1&bar=2');
      });
      it('POST to the problem reset page', function() {
        spyOn($, 'postWithPrefix');
        this.problem.reset();
        return expect($.postWithPrefix).toHaveBeenCalledWith('/problem/Problem1/problem_reset', {
          id: 'i4x://edX/101/problem/Problem1'
        }, jasmine.any(Function));
      });
      return it('render the returned content', function() {
        spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
          return callback({
            html: "Reset!"
          });
        });
        this.problem.reset();
        return expect(this.problem.el.html()).toEqual('Reset!');
      });
    });
    describe('show', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xmodule_display'));
        return this.problem.el.prepend('<div id="answer_1_1" /><div id="answer_1_2" />');
      });
      describe('when the answer has not yet shown', function() {
        beforeEach(function() {
          return this.problem.el.removeClass('showed');
        });
        it('log the problem_show event', function() {
          this.problem.show();
          return expect(Logger.log).toHaveBeenCalledWith('problem_show', {
            problem: 'i4x://edX/101/problem/Problem1'
          });
        });
        it('fetch the answers', function() {
          spyOn($, 'postWithPrefix');
          this.problem.show();
          return expect($.postWithPrefix).toHaveBeenCalledWith('/problem/Problem1/problem_show', jasmine.any(Function));
        });
        it('show the answers', function() {
          spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
            return callback({
              answers: {
                '1_1': 'One',
                '1_2': 'Two'
              }
            });
          });
          this.problem.show();
          expect($('#answer_1_1')).toHaveHtml('One');
          return expect($('#answer_1_2')).toHaveHtml('Two');
        });
        it('toggle the show answer button', function() {
          spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
            return callback({
              answers: {}
            });
          });
          this.problem.show();
          return expect($('.show .show-label')).toHaveText('Hide Answer(s)');
        });
        it('add the showed class to element', function() {
          spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
            return callback({
              answers: {}
            });
          });
          this.problem.show();
          return expect(this.problem.el).toHaveClass('showed');
        });
        describe('multiple choice question', function() {
          beforeEach(function() {
            return this.problem.el.prepend('<label for="input_1_1_1"><input type="checkbox" name="input_1_1" id="input_1_1_1" value="1"> One</label>\n<label for="input_1_1_2"><input type="checkbox" name="input_1_1" id="input_1_1_2" value="2"> Two</label>\n<label for="input_1_1_3"><input type="checkbox" name="input_1_1" id="input_1_1_3" value="3"> Three</label>\n<label for="input_1_2_1"><input type="radio" name="input_1_2" id="input_1_2_1" value="1"> Other</label>');
          });
          return it('set the correct_answer attribute on the choice', function() {
            spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
              return callback({
                answers: {
                  '1_1': [2, 3]
                }
              });
            });
            this.problem.show();
            expect($('label[for="input_1_1_1"]')).not.toHaveAttr('correct_answer', 'true');
            expect($('label[for="input_1_1_2"]')).toHaveAttr('correct_answer', 'true');
            expect($('label[for="input_1_1_3"]')).toHaveAttr('correct_answer', 'true');
            return expect($('label[for="input_1_2_1"]')).not.toHaveAttr('correct_answer', 'true');
          });
        });
        return describe('radio text question', function() {
          var radio_text_xml;
          radio_text_xml = '<section class="problem">\n  <div><p></p><span><section id="choicetextinput_1_2_1" class="choicetextinput">\n\n<form class="choicetextgroup capa_inputtype" id="inputtype_1_2_1">\n  <div class="indicator_container">\n    <span class="unanswered" style="display:inline-block;" id="status_1_2_1"></span>\n  </div>\n  <fieldset>\n    <section id="forinput1_2_1_choiceinput_0bc">\n      <input class="ctinput" type="radio" name="choiceinput_1_2_1" id="1_2_1_choiceinput_0bc" value="choiceinput_0"">\n      <input class="ctinput" type="text" name="choiceinput_0_textinput_0" id="1_2_1_choiceinput_0_textinput_0" value=" ">\n      <p id="answer_1_2_1_choiceinput_0bc" class="answer"></p>\n    </>\n    <section id="forinput1_2_1_choiceinput_1bc">\n      <input class="ctinput" type="radio" name="choiceinput_1_2_1" id="1_2_1_choiceinput_1bc" value="choiceinput_1" >\n      <input class="ctinput" type="text" name="choiceinput_1_textinput_0" id="1_2_1_choiceinput_1_textinput_0" value=" " >\n      <p id="answer_1_2_1_choiceinput_1bc" class="answer"></p>\n    </section>\n    <section id="forinput1_2_1_choiceinput_2bc">\n      <input class="ctinput" type="radio" name="choiceinput_1_2_1" id="1_2_1_choiceinput_2bc" value="choiceinput_2" >\n      <input class="ctinput" type="text" name="choiceinput_2_textinput_0" id="1_2_1_choiceinput_2_textinput_0" value=" " >\n      <p id="answer_1_2_1_choiceinput_2bc" class="answer"></p>\n    </section></fieldset><input class="choicetextvalue" type="hidden" name="input_1_2_1" id="input_1_2_1"></form>\n</section></span></div>\n</section>';
          beforeEach(function() {
            return this.problem.el.prepend(radio_text_xml);
          });
          it('sets the correct class on the section for the correct choice', function() {
            spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
              return callback({
                answers: {
                  "1_2_1": ["1_2_1_choiceinput_0bc"],
                  "1_2_1_choiceinput_0bc": "3"
                }
              });
            });
            this.problem.show();
            expect($('#forinput1_2_1_choiceinput_0bc').attr('class')).toEqual('choicetextgroup_show_correct');
            expect($('#answer_1_2_1_choiceinput_0bc').text()).toEqual('3');
            expect($('#answer_1_2_1_choiceinput_1bc').text()).toEqual('');
            return expect($('#answer_1_2_1_choiceinput_2bc').text()).toEqual('');
          });
          return it('Should not disable input fields', function() {
            spyOn($, 'postWithPrefix').andCallFake(function(url, callback) {
              return callback({
                answers: {
                  "1_2_1": ["1_2_1_choiceinput_0bc"],
                  "1_2_1_choiceinput_0bc": "3"
                }
              });
            });
            this.problem.show();
            expect($('input#1_2_1_choiceinput_0bc').attr('disabled')).not.toEqual('disabled');
            expect($('input#1_2_1_choiceinput_1bc').attr('disabled')).not.toEqual('disabled');
            expect($('input#1_2_1_choiceinput_2bc').attr('disabled')).not.toEqual('disabled');
            return expect($('input#1_2_1').attr('disabled')).not.toEqual('disabled');
          });
        });
      });
      return describe('when the answers are already shown', function() {
        beforeEach(function() {
          this.problem.el.addClass('showed');
          this.problem.el.prepend('<label for="input_1_1_1" correct_answer="true">\n  <input type="checkbox" name="input_1_1" id="input_1_1_1" value="1" />\n  One\n</label>');
          $('#answer_1_1').html('One');
          return $('#answer_1_2').html('Two');
        });
        it('hide the answers', function() {
          this.problem.show();
          expect($('#answer_1_1')).toHaveHtml('');
          expect($('#answer_1_2')).toHaveHtml('');
          return expect($('label[for="input_1_1_1"]')).not.toHaveAttr('correct_answer');
        });
        it('toggle the show answer button', function() {
          this.problem.show();
          return expect($('.show .show-label')).toHaveText('Show Answer(s)');
        });
        return it('remove the showed class from element', function() {
          this.problem.show();
          return expect(this.problem.el).not.toHaveClass('showed');
        });
      });
    });
    describe('save', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xmodule_display'));
        return this.problem.answers = 'foo=1&bar=2';
      });
      it('log the problem_save event', function() {
        this.problem.save();
        return expect(Logger.log).toHaveBeenCalledWith('problem_save', 'foo=1&bar=2');
      });
      it('POST to save problem', function() {
        spyOn($, 'postWithPrefix');
        this.problem.save();
        return expect($.postWithPrefix).toHaveBeenCalledWith('/problem/Problem1/problem_save', 'foo=1&bar=2', jasmine.any(Function));
      });
      return xit('alert to the user', function() {
        spyOn(window, 'alert');
        spyOn($, 'postWithPrefix').andCallFake(function(url, answers, callback) {
          return callback({
            success: 'OK'
          });
        });
        this.problem.save();
        return expect(window.alert).toHaveBeenCalledWith('Saved');
      });
    });
    describe('refreshMath', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xmodule_display'));
        $('#input_example_1').val('E=mc^2');
        return this.problem.refreshMath({
          target: $('#input_example_1').get(0)
        });
      });
      return it('should queue the conversion and MathML element update', function() {
        return expect(MathJax.Hub.Queue).toHaveBeenCalledWith(['Text', this.stubbedJax, 'E=mc^2'], [this.problem.updateMathML, this.stubbedJax, $('#input_example_1').get(0)]);
      });
    });
    describe('updateMathML', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xmodule_display'));
        return this.stubbedJax.root.toMathML.andReturn('<MathML>');
      });
      describe('when there is no exception', function() {
        beforeEach(function() {
          return this.problem.updateMathML(this.stubbedJax, $('#input_example_1').get(0));
        });
        return it('convert jax to MathML', function() {
          return expect($('#input_example_1_dynamath')).toHaveValue('<MathML>');
        });
      });
      return describe('when there is an exception', function() {
        beforeEach(function() {
          this.stubbedJax.root.toMathML.andThrow({
            restart: true
          });
          return this.problem.updateMathML(this.stubbedJax, $('#input_example_1').get(0));
        });
        return it('should queue up the exception', function() {
          return expect(MathJax.Callback.After).toHaveBeenCalledWith([this.problem.refreshMath, this.stubbedJax], true);
        });
      });
    });
    return describe('refreshAnswers', function() {
      beforeEach(function() {
        this.problem = new Problem($('.xmodule_display'));
        this.problem.el.html('<textarea class="CodeMirror" />\n<input id="input_1_1" name="input_1_1" class="schematic" value="one" />\n<input id="input_1_2" name="input_1_2" value="two" />\n<input id="input_bogus_3" name="input_bogus_3" value="three" />');
        this.stubSchematic = {
          update_value: jasmine.createSpy('schematic')
        };
        this.stubCodeMirror = {
          save: jasmine.createSpy('CodeMirror')
        };
        $('input.schematic').get(0).schematic = this.stubSchematic;
        return $('textarea.CodeMirror').get(0).CodeMirror = this.stubCodeMirror;
      });
      it('update each schematic', function() {
        this.problem.refreshAnswers();
        return expect(this.stubSchematic.update_value).toHaveBeenCalled();
      });
      it('update each code block', function() {
        this.problem.refreshAnswers();
        return expect(this.stubCodeMirror.save).toHaveBeenCalled();
      });
      return xit('serialize all answers', function() {
        this.problem.refreshAnswers();
        return expect(this.problem.answers).toEqual("input_1_1=one&input_1_2=two");
      });
    });
  });

}).call(this);
